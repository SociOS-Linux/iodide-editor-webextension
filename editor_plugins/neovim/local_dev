import pynvim
## TODO look into why is this imported twice?
import threading
import json
import time
import datetime
from SimpleWebSocketServer import SimpleWebSocketServer, WebSocket

all_messages= ""
all_connections =[]
nvims = []
## apparently self.data is a json like object
class SimpleEcho(WebSocket):
    def update(self,info):
        print("info is",info)
        nvims[-1].buffers[1][:] =info.split("\n")
        ## note that this will also trigger a buffer change, so it will auto update the editor one more time
    def handleMessage(self):
        print("handling iodide message",self.data)
        if len(nvims) >0:
            nvims[0].async_call(self.update,self.data)
    def sm(self,message):
        self.sendMessage(message)
    def handleConnected(self):
        print(self.address, 'connected')
        all_connections.append(self)
    def handleClose(self):
        print(self.address, 'closed')


import pynvim

class TestPlugin(object):
    def __init__(self, nvim):
        self.nvim = nvim
    def close_comm(self):
        self.server.close()
    def start_comm(self):
        self.com_clear =True
        ## register the keyboard mapping to send requests to the web browser 
        self.nvim.command("nnoremap <C-e> :call rpcnotify({},'evalreq')<CR>".format(self.nvim.channel_id))
        ## register to receive buffer change events
        ## setup the server
        nvims.append(self.nvim)
        server = SimpleWebSocketServer('', 9876, SimpleEcho)
        self.server = server
        threading.Thread(target=server.serveforever).start()
        ## in background setup timer to send whole buffer to iodide every 5 seconds
        ## begin the next message checker
        ## might have to be in async_call? 


## make autocommand
neovim.command(":au InsertEnter * :call rpcnotify({},'insertenter')".format(neovim.channel_id))
neovim.command(":au InsertLeave * :call rpcnotify({},'insertleave')".format(neovim.channel_id))


plugs = []

testplugob.close_comm()
#make a test object

plugs.append( TestPlugin(neovim))

# start the communicator
#
testplugob = plugs[-1]
testplugob.start_comm()

import difflib
from pprint import pprint

class Handler(object):
  def __init__(self,nvim):
    self.nvim = nvim
    self.prev_buffer = self.nvim.current.buffer[:]
    self.prev_pos= [0,0]
    self.com_clear=False ## specifies whether the user has activated communication
    self.d = difflib.Differ()
  def send_whole_document(self):
    ## the default behavior without a specific tyep is to replace the iomd_content
    msg_object = {"text":"\n".join(self.nvim.current.buffer[:])}
    all_connections[-1].sm(json.dumps(msg_object))
  def eval_req(self):
    msg_object = {"type":"EVAL_CHUNK"}
    all_connections[-1].sm(json.dumps(msg_object))
  def get_diff(self):
    current_buffer = self.nvim.current.buffer[:]
    difference = list(self.d.compare(self.prev_buffer,current_buffer))
    print("previous --{}--".format(self.prev_buffer))
    print("current --{}--".format(current_buffer))
    pprint(difference)
    ## toss out the question mark lines
    difference = [d for d in difference if d[0] != "?"]
    self.prev_buffer = current_buffer
    return difference
  def insert_line(self,line,line_num):
    ## if line is '' then we just created a newline and exited but there's also a good chance this wil get caught on the next actual addition to the line
    message_ob = {"type":"INSERT_TEXT","pos":[line_num,0],"text":line}
    print(message_ob)
    all_connections[-1].sm(json.dumps(message_ob))
  def delete_line(self,line,line_num):
      message_ob = {"pos":[line_num,1],"type":"DELETE_TEXT","numCharsToDelete":1}
      print(message_ob)
      all_connections[-1].sm(json.dumps(message_ob))
  def dif_digest(self,dif):
    #iterate over the dif for lines that are - call send delete line
    # for + send insert line 
    for line_ind,line in enumerate(dif):
      ## skip the first two chars of the string because they aren't the actual text
      print(line_ind,line)
      if line == "":
        continue
      if line[0] == "-":
        print("delete line",line)
        self.delete_line(line[2:],line_ind)
      if line[0] == "+":
        print("insert line",line)
        # check if this is a line modification or creation
        if line_ind != 0 and dif[line_ind-1][0] == "-":
          self.insert_line(line[2:],line_ind-1) ## the line_ind is always one higher than its supposed to be for the inserted details from the dif when teh line has been modified
        else:
          self.insert_line(line[2:],line_ind)
  def enter_insert(self):
    ## compare current with previous buffer and print it
    print("getting enter dif")
    dif = self.get_diff()
    self.dif_digest(dif)
  def exit_insert(self):
    print("getting exit dif")
    dif = self.get_diff()
    self.dif_digest(dif)
## create an autocommand which notifies on texchange
#

## hook up the other stuff to the loop
h = Handler(nvim)
prev = [0,0]
while True:
  # blocking call which is why we don't have to go to sleep in a while loop
  res = neovim.next_message()
  print("res is ",res)
  if res == None:
    continue
  cursor = neovim.request("nvim_get_current_win").cursor
  if res[1] == "insertenter":
    h.enter_insert()
  if res[1] == "insertleave":
    print("left")
    h.exit_insert()
  prev= cursor





# create testplugin object
# TODO rename it too
# run startcomm
# connect methods of the object to parts of the while loop
# must create correct autocommands for various things with the right messages
#   text change
#   leaving of insert
#   perhaps the entering of insert too, for better tracking delet and insert
#   eval_req
#
